</br>

# SegmentTree

</br>

<p>二叉树除最后一层外为满二叉树，假如用线段树来维护 1～10 这个区间，那么根节点就是 1～10，每个区间会有两个子区间（根据 mid），为 [l, mid] [mid+1, r]。</p>

<p>可以用一维数组来存整棵树，对于长度为 n 的区间，最后一个全满层最坏会有 n 个点，把和前面的加在一起最多会有 2n-1 个点，最后一层最坏情况下为最后一个全满层的两倍，<b>所以最多会有 4n-1 个点</b></p>

<p>有 pushup 和 pushdown 操作，pushup 是由子节点去算父节点的信息，比如想要计算当前区间的总和是多少 sum = l.sum + r.sum。pushdown (也被称为延迟标记) 是把当前父节点的修改信息下传到子节点</p>

<p>最简单的线段树会有四个操作：</p>

- pushup(u)

- build() 将一段区间初始化为线段树

- modify() 修改单点或者区间

- query() 查询某一段区间的信息

<p>build 传入当前区间编号，以及当前区间的左右端点</p>

```
void build(int u, int l, int r)
{
    tr[u].l = l, tr[u].r = r;
    if(l == r) return; // 若当前为叶子节点直接返回即可
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}
```

</br>

## 查询

</br>

<p>修改操作和查询操作是类似的，来看查询操作。比如要找某一个区间内的最大值，线段树内每个点存当前区间的最大值，分为几种情况，[l, r] 表示要查询的区间，[Tl, Tr] 表示树中节点的范围是多少。<b>O(logn)</b></p>

<img width="1016" height="706" alt="QQ_1758026505466" src="https://github.com/user-attachments/assets/27e29191-3e81-4f04-9808-97faee9eee4b" />

- [Tl, Tr] 属于 [l, r]，那么不用递归直接返回当前区间最大值就可以了

- 两个区间有交集，和左边有交集就递归左边，和右边有交集就递归右边，有可能同时都会被递归
   1. Tl <= l <= Tr <= r
      - l > mid 只递归右边
    
      - l <= mid 左右都递归（右半边区间全包含，为 O(1)，所以不会影响复杂度）
 
  2. 以及上面的对称情况
 
  3. Tl <= l <= r << Tr
 
     - r <= mid 只递归左边
    
     - l > mid 只递归右边
    
     - 其他情况，会递归两边。分析复杂度，会存在两条链，但这种分裂情况只会出现一次，所以还是 O(logn) *:

- 不存在第三种情况，那就是两个区间没有交集，因为达不到

<p>*: 分裂操作只会进行一次，后面的操作一定是在前几种里面，故最多两条链</p>

<img width="950" height="676" alt="QQ_1758027695123" src="https://github.com/user-attachments/assets/b6f5afd0-6f64-4516-a81e-487f963979f0" />

</br>

## 单点修改

</br>

<p></p>











































































































































































































































































