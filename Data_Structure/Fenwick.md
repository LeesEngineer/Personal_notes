<p>数据结构三大难点：线段树，Splay，块状链表</p>

</br>

# 基本原理

</br>

<p>树状数组解决两个问题：</p>

1. 快速求前缀和 O(logn)

2. 修改某个数 O(logn)

<p>相比维护:</p>
  
1. 数组：O(n), O(1)
2. 前缀和数组：O(1), O(n)

<p>树状数组基于二进制的想法解决问题，比如:</p>

`x = 2^(i_k) + 2^(i_k-1) + 2^(i_k-2) + ... + 2^(i_1), k <= logx`

<p>可以把 1 ～ x 这个区间，用 i 划分成 k 段</p>

```
// 从低位开始减
(x - 2^(i_1), x]                                 // 包含 2^(i_1) 个数
(x - 2^(i_1) - 2^(i_2), x - 2^(i_1)]       
...
(0, x - 2^(i_1) - 2^(i_2) - ... - 2^(i_k-1)]     // 包含 2^(i_k) 个数
```

<p>把 1～x 分成最多 logx 个部分，最多只需要加上 logx 个数就能算出来 1～x</p>

<p>(L, R] 长度一定是 R 的二进制表示的最后一位 1 所对应的次幂</p>

```
int lowbit(int x)
{
    return x & -x;
}
```

<p>所以 (L, R] = (R - lowbit(R), R]。那就可以用一个数组来表示这个区间的和：</p>

`C[R] = [R - lowbit(R) + 1  , R]`

<p>最多有 n 个区间，因为区间是被右端点唯一确定的</p>

`c[x] = a[x - bowbit(x) + 1, x]`

<p>c[x] 表示以 x 为右端点，长度为 lowbit(x) 的区间的所有元素的和</p>

<p>考虑 c[x] 间的关系</p>

```

```





 















</br>

# 扩展

</br>

<p></p>

</br>

## 扩展--差分

</br>

<p></p>

</br>

## 扩展--查分+公式

</br>

<p></p>

</br>

# 例题

</br>

<p></p>








































































































































































































































































































































































































