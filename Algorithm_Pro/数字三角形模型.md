</br>

# 数字三角形

</br>

```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, INF = 1e9;

int n;
int a[N][N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= i; j++)
            scanf("%d", &a[i][j]);
            
    for(int i = 0; i <= n; i++)
        for(int j = 0; j <= i + 1; j++)
            f[i][j] = -INF;
            
    f[1][1] = a[1][1];
    for(int i = 2; i <= n; i++)
        for(int j = 1; j <= i; j++)
            f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);
    
    int res = -INF;
    for(int i = 1; i <= n; i++) res = max(res, f[n][i]);
    printf("%d\n", res);
    return 0;
}
```

</br>

# 摘花生

</br>

<p>传统 DP 需要考虑：阶段，决策，最优子结构，无后效性</p>

<p>新的思考方式——从集合角度来考虑 DP 问题</p>

<p>动态规划：</p>

- 状态表示 f[i, j]

- - 集合：所有从 (1, 1) 走到 (i, j) 的路线
 
  - 属性（max， min， 数量）：所有路线的最大值

- 集合划分

```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, INF = 1e9;

int g[N][N];

int f[N][N];

int main()
{
    int t;
    cin >> t;
    while(t --)
    {
        int r, c;
        cin >> r >> c;
        
        for(int i = 1; i <= r; i ++)
            for(int j = 1; j <= c; j ++)
                cin >> g[i][j];
        
        for(int i = 0; i <= r; i ++)
            for(int j = 0; j <= c; j ++)
                f[i][j] = -INF;
                
        f[0][1] = 0;
        
        for(int i = 1; i <= r; i ++)
            for(int j = 1; j <= c; j ++)
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + g[i][j];
                
        cout << f[r][c] << endl;
    }
}
```

</br>

# 最低通行费

</br>

<p>一个商人穿过一个 N×N的正方形的网格，去参加一个非常重要的商务活动。他要从网格的左上角进，右下角出。每穿越中间 1 个小方格，都要花费 1 个单位时间。商人必须在 (2N−1) 个单位时间穿越出去。而在经过中间的每个小方格时，都需要缴纳一定的费用。这个商人期望在规定时间内用最少费用穿越出去。请问至少需要多少费用？</p>

<p>2N - 1 意味着不走回头路，所以本质就是摘花生</p>

```
{
    int n;
    cin >> n;
    
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            cin >> g[i][j];
            
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            if(i == 1 && j == 1)
            {
                f[i][j] = g[i][j];
            }
            else
            {
                f[i][j] = INF;
                if(i > 1) f[i][j] = min(f[i][j], f[i - 1][j] + g[i][j]);
                if(j > 1) f[i][j] = min(f[i][j], f[i][j - 1] + g[i][j]);
            }
            
    cout << f[n][n];
}
```

</br>

# 方格取数

</br>

<p></p>



























































































































































































