# 最大流问题

</br>

<p>对于一条边 (u, v)，规定 f(u, v) = -f(v ,u)。这样规定就好比“把三个物品从 u 送到 v”等价于“把 -3 个物品从 v 送到 u”</p>

<p>在最大流问题中，c 和 f 满足三个性质：</p>

- 容量限制：f(u, v) <= c(u, v)

- 斜对称性：f(u, v) = -f(v, u)

- 流量平衡：对于除了 s 和 t 以外的所有任意结点 u，`\sum_{(u, v) in E}f(u, v) = 0`

<p>目标是最大化 |f|</p> 

$$
|f| = \sum_{(s, v) \in E}f(s, v) = \sum_{(u, t) \in E}f(u, t)
$$

</br>

# 增广路算法

</br>

<p>计算每条边上容量与流量之差为残量，得到残量网络</p>

<p>该算法基于这样一个事实：残量网络中任何一条从 s 到 t 的有向道路都对应一条原图中的增广路(augmenting path)，只要求出该道路中所有残量的最小值 d，把对应的所有边上的流量增加 d 即可，该过程称为增广。</p>

<p>显然只要残量网络中存在增广路，流量就可以增大。逆命题也成立：如果残量网络中不存在增广路，则当前流就是最大流</p>

<p>找任意路径最简单的办法无疑是用 DFS，但很容易找到让算法很慢的例子，稍好的方法是使用 BFS，这就是 Edmonds-Karp 算法</p>

<p>虽然有了 flow 和 cap，但得益于Edge结构体的设计，Edmonds-Karp 和 Dijkstra 等算法很相近</p>

```
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e7;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int cap, flow;
};

int h[N];
int ne[N];
int e[N];
Edge w[N];
int idx;

int a[N]; // a 记录改进量
int p[N]; // p 记录入点

void add(int a, int b, Edge c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}

int EdmondsKarp(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0, sizeof a);
        queue<int> q;
        q.push(s);
        a[s] = INF;
        while(!q.empty())
        {
            int x = q.front();
            q.pop();
            for(int i = h[x]; i != -1; i = ne[i])
            {
                int y = e[i];
                int c = w[i].cap, f = w[i].flow;
                if(!a[y] && c > f) // 这里 !a[y] 很细节
                {
                    p[y] = x;
                    a[y] = min(a[x], c - f);
                    q.push(y);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        
        for(int u = t; u != s; u = p[u])
        {
            for(int i = h[p[u]]; i != -1; i = ne[i]) // 不能处理重边问题就出在这里，因为记录的是点的索引，而不是边的索引
                if(e[i] == u)
                {
                    w[i].flow += a[t];
                    w[i^1].flow -= a[t];
                }
        }
        flow += a[t];
    }
    return flow;
}

int main()
{
    memset(h, -1, sizeof h);
    
    int n, m;
    cin >> n >> m;
    
    for(int i = 0; i < m; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, {c, 0}), add(b, a, {0, 0});
    }
    
    int f = EdmondsKarp(1, n);
    cout << f;
}
```

<p>该版本能处理环，<b>但无法处理重边</b></p>

```
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e7;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int from, to, cap, flow;
};

int h[N];
int ne[N];
Edge e[N];
int idx;

int a[N]; // a 记录改进量
int p[N]; // p 记录入点

void add(int a, int b, int c)
{
    e[idx] = {a, b, c, 0}, ne[idx] = h[a], h[a] = idx ++;
}

int EdmondsKarp(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0, sizeof a);
        queue<int> q;
        q.push(s);
        a[s] = INF;
        while(!q.empty())
        {
            int x = q.front();
            q.pop();
            for(int i = h[x]; i != -1; i = ne[i])
            {
                int y = e[i].to;
                int c = e[i].cap, f = e[i].flow;
                if(!a[y] && c > f) // 这里 !a[y] 很细节
                {
                    p[y] = i;
                    a[y] = min(a[x], c - f);
                    q.push(y);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        
        for(int u = t; u != s; u = e[p[u]].from)
        {
            e[p[u]].flow += a[t];
            e[p[u]^1].flow -= a[t];
        }
        flow += a[t];
    }
    return flow;
}

int main()
{
    int t;
    cin >> t;
    while(t --)
    {

        memset(h, -1, sizeof h);
        
        int n, m;
        cin >> n >> m;
        
        for(int i = 0; i < m; i ++)
        {
            int a, b, c;
            cin >> a >> b >> c;
            add(a, b, c), add(b, a, 0);
        }
        
        int f = EdmondsKarp(1, n);
        cout << f << endl;
    }
}
```

<p>自我改进版</p>

```
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;

vector<vector<int>>g;
vector<int> pre;
vector<int> a;
int n, m;

int EK(){
    int flow=0;
    queue<int> q;
    while(true){
        q.push(1);
        a.assign(n+1,0);
        a[1]=1000;//源点流量无穷大
        while(!q.empty()){
            int vex=q.front();
            q.pop();
            for(int i=1;i<n+1;i++){
                if(g[vex][i]>0 && a[i]==0){
                    a[i]=min(a[vex],g[vex][i]);
                    q.push(i);
                    pre[i]=vex;
                }
            }
        }
        if(a[n]==0){
            return flow;
        }
        flow+=a[n];
        for(int i=n;i!=1;i=pre[i]){//更新剩余网络
            g[pre[i]][i]-=a[n];
            g[i][pre[i]]+=a[n];
        }
    }

}

int main()
{
    cin>>n>>m;
    g.assign(n+1,vector<int>(n+1));
    pre.assign(n+1,0);
    int u, v, c;
    for(int i=0;i<m;i++){
        cin>>u>>v>>c;
        g[u][v]+=c;
    }
    cout<<EK();
    return 0;
}
```

<p>别人的答案</p>































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































