<p>网络流是图论中的一个博大精深的分支</p>

</br>

# 最大流

</br>

<p>对于一条边 (u, v)，规定 f(u, v) = -f(v ,u)。这样规定就好比“把三个物品从 u 送到 v”等价于“把 -3 个物品从 v 送到 u”</p>

<p>在最大流问题中，c 和 f 满足三个性质：</p>

- 容量限制：f(u, v) <= c(u, v)

- 斜对称性：f(u, v) = -f(v, u)

- 流量平衡：对于除了 s 和 t 以外的所有任意结点 u，`\sum_{(u, v) in E}f(u, v) = 0`

<p>目标是最大化 |f|</p> 

$$
|f| = \sum_{(s, v) \in E}f(s, v) = \sum_{(u, t) \in E}f(u, t)
$$

</br>

## Edmonds-Karp 增广路算法

</br>

<p>计算每条边上容量与流量之差为残量，得到残量网络</p>

<p>该算法基于这样一个事实：残量网络中任何一条从 s 到 t 的有向道路都对应一条原图中的增广路(augmenting path)，只要求出该道路中所有残量的最小值 d，把对应的所有边上的流量增加 d 即可，该过程称为增广。</p>

<p>显然只要残量网络中存在增广路，流量就可以增大。逆命题也成立：如果残量网络中不存在增广路，则当前流就是最大流</p>

<p>找任意路径最简单的办法无疑是用 DFS，但很容易找到让算法很慢的例子，稍好的方法是使用 BFS，这就是 Edmonds-Karp 算法</p>

<p>虽然有了 flow 和 cap，但得益于Edge结构体的设计，Edmonds-Karp 和 Dijkstra 等算法很相近</p>

```
// 脱胎于刘汝佳的版本
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e7;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int from, to, cap, flow;
};

int h[N];
int ne[N];
Edge e[N];
int idx;

int a[N]; // a 记录改进量
int p[N]; // p 记录入点

void add(int a, int b, int c)
{
    e[idx] = {a, b, c, 0}, ne[idx] = h[a], h[a] = idx ++;
}

int EdmondsKarp(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0, sizeof a);
        queue<int> q;
        q.push(s);
        a[s] = INF;
        while(!q.empty())
        {
            int x = q.front();
            q.pop();
            for(int i = h[x]; i != -1; i = ne[i])
            {
                int y = e[i].to;
                int c = e[i].cap, f = e[i].flow;
                if(!a[y] && c > f) // 这里 !a[y] 很细节
                {
                    p[y] = i;
                    a[y] = min(a[x], c - f);
                    q.push(y);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        
        for(int u = t; u != s; u = e[p[u]].from)
        {
            e[p[u]].flow += a[t];
            e[p[u]^1].flow -= a[t];
        }
        flow += a[t];
    }
    return flow;
}

int main()
{
    int t;
    cin >> t;
    while(t --)
    {

        memset(h, -1, sizeof h);
        
        int n, m;
        cin >> n >> m;
        
        for(int i = 0; i < m; i ++)
        {
            int a, b, c;
            cin >> a >> b >> c;
            add(a, b, c), add(b, a, 0);
        }
        
        int f = EdmondsKarp(1, n);
        cout << f << endl;
    }
}
```

<p>一条从源点 S 到汇点 T 的路径上各边的剩余容量都大于 0，则为增广路。Edmonds-Karp 算法的思想就是不断用 BFS 寻找增广路。</p>

<p>Edmonds-Karp 只考虑 f(x, y) < c(x, y) 的边。</p>

<p>需要注意，根据斜对称性，当一条边的流量大于 0，他的反向边的流量就小于 0，此时必定有 f(y, x) < c(y, x)。故 Edmonds-Karp 在 BFS 时，除了原边集 E 之外，还应该考虑 E 中每条边的反向边</p>

<p>具体实现时，可以按照邻接表“成对存储”技巧。只记录残余网络即可（每条边只记录剩余容量 c-f）</p>

<p>Edmonds-Karp 时间复杂度为 O(nm^2)，效率较高，一般能处理 10^3 ~ 10^4 规模的网络</p>

```
// y总版
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int INF = 1 << 29, N = 2010, M = 20010;

int h[N], e[M], ne[M], w[M], idx;
int st[N], a[N], p[N];

int n, m, s, t, flow;

void add(int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}

bool bfs()
{
    memset(st, 0, sizeof st);
    queue<int> q;
    q.push(s);
    st[s] = 1;
    a[s] = INF;
    while(!q.empty())
    {
        int x = q.front();
        q.pop();
        for(int i = h[x]; i != -1; i = ne[i])
        {
            if(w[i])
            {
                int y = e[i];
                if(st[y]) continue;
                a[y] = min(a[x], w[i]);
                p[y] = i;
                q.push(y), st[y] = 1;
                if(y == t) return 1;
            }
        }
    }
    return 0;
}

void update()
{
    int x = t;
    while(x != s)
    {
        int i = p[x];
        w[i] -= a[t];
        w[i^1] += a[t];
        x = e[i^1];
        // 这两行利用“成对存储“的 xor 1 技巧
    }
    flow += a[t];
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    s = 1, t = n; idx = 0; flow = 0;
    for(int i = 0;i < m; i ++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        add(b, a, 0);
    }
    while(bfs()) update();
    cout << flow << endl;
}
```

</br>

## Dinic

</br>

<p></p>

</br>

# 最小费用最大流问题

</br>

<p>给网络流增加一个因素：费用（a）。假设每条边除了有一个容量限制外，还有一个单位流量所需的费用</p>

<p>在最小费用流问题中，平行边就变得有意义了，由于费用的出现，无法合并这两条弧</p>

<p>为了方便描述算法，先假定图中不存在平行边和反向边，可以使用两个邻接矩阵 cap 和 cost 来保存各自的费用和容量，为了允许反向增广，规定 cap[v][u] = 0 并且 cost[v][u] = -coat[u][v]，表示沿着 (u, v) 反向增广时，费用减少 cost[u][v]</p>

<p>最小费用算法和 Edmonds-Karp 算法类似，但每次使用 Bellman-Ford 算法而非 BFS 找增广路（用 SPFA 也可以）。<b>用最短路算法计算图的距离标号，然后沿着可行边进行增广</b></p>
    
<p><b>只要初始流是该流量下的最小费用可行流，每次增广后的新流都是新流量下的最小费用流</b>。另外，费用可正可负</p>

```
// 官解
struct Edge
{
    int from, to, cap, flow, cost;
};

struct MCMF
{
    int n, m;
    vector<Edge> edges;
    vector<int> G[N];
    
    int inq[N];
    int d[N];
    int p[N];
    int a[N];
    
    void init(int n)
    {
        this -> n = n;
        for(int i = 0; i < n; i ++) G[i].clear();
        edges.clear();
    }
    
    void AddEgde(int from, int to, int cap, int cost)
    {
        edges.push_back({from, to, cap, 0, cost});
        edges.push_back({to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    
    bool BellmanFord(int s, int t, int &flow, long long &cost)
    {
        for(int i = 0; i < n; i ++)d[i] = INF;
        memset(inq, 0, sizeof inq);
        d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF;
        
        queue<int> Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = 0;
            
            for(int i = 0; i < G[u].size(); i ++)
            {
                Edge &e = edges[G[u][i]];
                if(e.cap > e.flow && d[e.to] > d[u] + e.cost)
                {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = 1;
                    }
                }
            }
        }
        if(d[t] == INF) return false;
        flow += a[t];
        cost += (long long)d[t] * (long long)a[t];
        for(int u = t; u != s; u = edges[p[u]].from)
        {
            edges[p[u]].flow += a[t];
            edges[p[u]^1].flow -= a[t];
        }
        return true;
    }
    
    int MincostMaxflow(int s, int t, long long & cost) // 要确保没有负环
    {
        int flow = 0; cost = 0;
        while(BellmanFord(s, t, flow, cost));
        return flow;
    }
};
```

```
//自写
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 1e5;

struct Edge
{
    int from, to, cap, flow, cost;
};

int h[N];
Edge e[N];
int ne[N];
int idx;

int p[N];
int a[N];

int st[N];
int d[N];

void add(int a, int b, int c, int d)
{
    e[idx] = {a, b, c, 0, d}, ne[idx] = h[a], h[a] = idx ++;
}

int MCMF(int s, int t, int &cost)
{
    int flow = 0; cost = 0;

    while(true)
    {
        memset(d, 0x3f, sizeof d);
        a[s] = 0x3f3f3f3f;

        queue<int> q;
        q.push(s);
        st[s] = 1;
        d[s] = 0;

        while(!q.empty())
        {
            int x = q.front();
            q.pop();
            st[x] = 0;
            
            for(int i = h[x]; i != -1; i = ne[i])
            {
                int y = e[i].to;
                if(e[i].cap > e[i].flow && d[y] > d[x] + e[i].cost)
                {
                    d[y] = d[x] + e[i].cost;
                    p[y] = i;
                    a[y] = min(a[x], e[i].cap - e[i].flow);
                    if(!st[y])
                    {
                        q.push(y);
                        st[y] = 1;
                    }
                }
            }
        }
        if(d[t] == 0x3f3f3f3f) break;

        flow += a[t];
        cost += a[t] * d[t];
        for(int u = t; u != s; u = e[p[u]].from)
        {
            e[p[u]].flow += a[t];
            e[p[u]^1].flow -= a[t];
        }
    }
    return flow;
}

int main()
{
    memset(h, -1, sizeof h);

    int n, m;
    cin >> n >> m;
    for(int i = 0; i < m; i ++)
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, c, d), add(b, a, 0, -d);
    }

    int flow, cost;
    flow = MCMF(1, n, cost);
    cout << flow << " " << cost;

    return 0;
}
```

</br>

# 二分图匹配

</br>

<p>关于二分图只有一句：一个图是二分图，当且仅当它不含长度为奇数的圈</p>

<p>常见的二分图匹配有两种：</p>

</br>

## 无权图

</br>

<p>第一种是针对无权图的，需要求出包含边数最多的匹配，即二分图的最大基数匹配</p>

<p>结合网络流的求解方法：增加一个源点 s 和一个汇点 t，从 s 到所有 X 结点各连一条容量为 1 的弧。再从 Y 结点各连一条容量为 1 的弧到 t。只要求出 s 到 t 的最大流，就求出了对应二分图的最大基数匹配</p>

</br>

## 带权图

</br>

<p>第二种是针对带权图的，需要求出边权之和尽量大的匹配。也分为两种，有些题目要求这个匹配本身是完美匹配（即每个点都被匹配到）。有些不对边的数量作出要求，只要劝和最大就可以了</p>

<p>先来看最大权完美匹配：和最大基数匹配一样，只是原二分图中所有边的费用为权值的相反数，然后其他边的费用为 0，然后求一个 s 到 t 的最小费用最大流即可。<b>如果从 s 出发的所有弧并不是全部满载，则完美匹配不存在</b></p>

<p>用这样的方法也可以求解第二种问题，即匹配边数没有限制的最大权匹配，只是需要在求解 s - t 最小费用最大流的过程记录下流量为 0, 1, 2, 3, ... 时的最小费用流，然后加以比较</p>














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































