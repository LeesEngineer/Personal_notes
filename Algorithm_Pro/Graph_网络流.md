# 最大流问题

</br>

<p>对于一条边 (u, v)，规定 f(u, v) = -f(v ,u)。这样规定就好比“把三个物品从 u 送到 v”等价于“把 -3 个物品从 v 送到 u”</p>

<p>在最大流问题中，c 和 f 满足三个性质：</p>

- 容量限制：f(u, v) <= c(u, v)

- 斜对称性：f(u, v) = -f(v, u)

- 流量平衡：对于除了 s 和 t 以外的所有任意结点 u，`\sum_{(u, v) in E}f(u, v) = 0`

<p>目标是最大化 |f|</p> 

$$
|f| = \sum_{(s, v) \in E}f(s, v) = \sum_{(u, t) \in E}f(u, t)
$$

</br>

# 增广路算法

</br>

<p>计算每条边上容量与流量之差为残量，得到残量网络</p>

<p>该算法基于这样一个事实：残量网络中任何一条从 s 到 t 的有向道路都对应一条原图中的增广路(augmenting path)，只要求出该道路中所有残量的最小值 d，把对应的所有边上的流量增加 d 即可，该过程称为增广。</p>

<p>显然只要残量网络中存在增广路，流量就可以增大。逆命题也成立：如果残量网络中不存在增广路，则当前流就是最大流</p>

<p>找任意路径最简单的办法无疑是用 DFS，但很容易找到让算法很慢的例子，稍好的方法是使用 BFS，这就是 Edmonds-Karp 算法</p>

<p>虽然有了 flow 和 cap，但得益于Edge结构体的设计，Edmonds-Karp 和 Dijkstra 等算法很相近</p>

```
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e7;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int cap, flow;
};

int h[N];
int ne[N];
int e[N];
Edge w[N];
int idx;

int a[N]; // a 记录改进量
int p[N]; // p 记录入点

void add(int a, int b, Edge c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}

int EdmondsKarp(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0, sizeof a);
        queue<int> q;
        q.push(s);
        a[s] = INF;
        while(!q.empty())
        {
            int x = q.front();
            q.pop();
            for(int i = h[x]; i != -1; i = ne[i])
            {
                int y = e[i];
                int c = w[i].cap, f = w[i].flow;
                if(!a[y] && c > f) // 这里 !a[y] 很细节
                {
                    p[y] = x;
                    a[y] = min(a[x], c - f);
                    q.push(y);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        
        for(int u = t; u != s; u = p[u])
        {
            for(int i = h[p[u]]; i != -1; i = ne[i]) // 不能处理重边问题就出在这里，因为记录的是点的索引，而不是边的索引
                if(e[i] == u)
                {
                    w[i].flow += a[t];
                    w[i^1].flow -= a[t];
                }
        }
        flow += a[t];
    }
    return flow;
}

int main()
{
    memset(h, -1, sizeof h);
    
    int n, m;
    cin >> n >> m;
    
    for(int i = 0; i < m; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, {c, 0}), add(b, a, {0, 0});
    }
    
    int f = EdmondsKarp(1, n);
    cout << f;
}
```

<p>该版本能处理环，<b>但无法处理重边</b></p>

```
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e7;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int from, to, cap, flow;
};

int h[N];
int ne[N];
Edge e[N];
int idx;

int a[N]; // a 记录改进量
int p[N]; // p 记录入点

void add(int a, int b, int c)
{
    e[idx] = {a, b, c, 0}, ne[idx] = h[a], h[a] = idx ++;
}

int EdmondsKarp(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0, sizeof a);
        queue<int> q;
        q.push(s);
        a[s] = INF;
        while(!q.empty())
        {
            int x = q.front();
            q.pop();
            for(int i = h[x]; i != -1; i = ne[i])
            {
                int y = e[i].to;
                int c = e[i].cap, f = e[i].flow;
                if(!a[y] && c > f) // 这里 !a[y] 很细节
                {
                    p[y] = i;
                    a[y] = min(a[x], c - f);
                    q.push(y);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        
        for(int u = t; u != s; u = e[p[u]].from)
        {
            e[p[u]].flow += a[t];
            e[p[u]^1].flow -= a[t];
        }
        flow += a[t];
    }
    return flow;
}

int main()
{
    int t;
    cin >> t;
    while(t --)
    {

        memset(h, -1, sizeof h);
        
        int n, m;
        cin >> n >> m;
        
        for(int i = 0; i < m; i ++)
        {
            int a, b, c;
            cin >> a >> b >> c;
            add(a, b, c), add(b, a, 0);
        }
        
        int f = EdmondsKarp(1, n);
        cout << f << endl;
    }
}
```

<p>自我改进版</p>

```
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;

vector<vector<int>>g;
vector<int> pre;
vector<int> a;
int n, m;

int EK(){
    int flow=0;
    queue<int> q;
    while(true){
        q.push(1);
        a.assign(n+1,0);
        a[1]=1000;//源点流量无穷大
        while(!q.empty()){
            int vex=q.front();
            q.pop();
            for(int i=1;i<n+1;i++){
                if(g[vex][i]>0 && a[i]==0){
                    a[i]=min(a[vex],g[vex][i]);
                    q.push(i);
                    pre[i]=vex;
                }
            }
        }
        if(a[n]==0){
            return flow;
        }
        flow+=a[n];
        for(int i=n;i!=1;i=pre[i]){//更新剩余网络
            g[pre[i]][i]-=a[n];
            g[i][pre[i]]+=a[n];
        }
    }

}

int main()
{
    cin>>n>>m;
    g.assign(n+1,vector<int>(n+1));
    pre.assign(n+1,0);
    int u, v, c;
    for(int i=0;i<m;i++){
        cin>>u>>v>>c;
        g[u][v]+=c;
    }
    cout<<EK();
    return 0;
}
```

<p>别人的答案</p>

</br>

# 最小费用最大流问题

</br>

<p>给网络流增加一个因素：费用（a）。假设每条边除了有一个容量限制外，还有一个单位流量所需的费用</p>

<p>在最小费用流问题中，平行边就变得有意义了，由于费用的出现，无法合并这两条弧</p>

<p>为了方便描述算法，先假定图中不存在平行边和反向边，可以使用两个邻接矩阵 cap 和 cost 来保存各自的费用和容量，为了允许反向增广，规定 cap[v][u] = 0 并且 cost[v][u] = -coat[u][v]，表示沿着 (u, v) 反向增广时，费用减少 cost[u][v]</p>

<p>最小费用算法和 Edmonds-Karp 算法类似，但每次使用 Bellman-Ford 算法而非 BFS 找增广路（用 SPFA 也可以）。<b>用最短路算法计算图的距离标号，然后沿着可行边进行增广</b></p>
    
<p><b>只要初始流是该流量下的最小费用可行流，每次增广后的新流都是新流量下的最小费用流</b>。另外，费用可正可负</p>

```
// 官解
struct Edge
{
    int from, to, cap, flow, cost;
};

struct MCMF
{
    int n, m;
    vector<Edge> edges;
    vector<int> G[N];
    
    int inq[N];
    int d[N];
    int p[N];
    int a[N];
    
    void init(int n)
    {
        this -> n = n;
        for(int i = 0; i < n; i ++) G[i].clear();
        edges.clear();
    }
    
    void AddEgde(int from, int to, int cap, int cost)
    {
        edges.push_back({from, to, cap, 0, cost});
        edges.push_back({to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    
    bool BellmanFord(int s, int t, int &flow, long long &cost)
    {
        for(int i = 0; i < n; i ++)d[i] = INF;
        memset(inq, 0, sizeof inq);
        d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF;
        
        queue<int> Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = 0;
            
            for(int i = 0; i < G[u].size(); i ++)
            {
                Edge &e = edges[G[u][i]];
                if(e.cap > e.flow && d[e.to] > d[u] + e.cost)
                {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = 1;
                    }
                }
            }
        }
        if(d[t] == INF) return flase;
        flow += a[t];
        cost += (long long)d[t] * (long long)a[t];
        for(int u = t; u != s; u = edges[p[u]].from)
        {
            edges[p[u]].flow += a[t];
            edges[p[u]^1].flow -= a[t];
        }
        return true;
    }
    
    int MincostMaxflow(int s, int t, long long & cost) // 要确保没有负环
    {
        int flow = 0, cost = 0;
        while(BellmanFord(s, t, flow, cost));
        return flow;
    }
};
```

```
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 1e5;

struct Edge
{
    int from, to, cap, flow, cost;
};

int h[N];
Edge e[M];
int ne[N];
int idx;

int p[N];
int a[N];

int inq[N];
int d[N];

void add(int a, int b, int c, int d)
{
    e[idx] = {a, b, c, 0, d}, ne[idx] = h[a], h[a] = idx ++;
}

int MCMF(int s, int t, int &cost)
{

}

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 0; i < m; i ++)
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, c, d), add(b, a, 0, -d);
    }

    int flow, cost;
    flow = MCMF(1, n, cost);
    cout << flow << " " << cost;

    return 0;
}


```
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































