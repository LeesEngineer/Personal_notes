# 最大流问题

</br>

<p>对于一条边 (u, v)，规定 f(u, v) = -f(v ,u)。这样规定就好比“把三个物品从 u 送到 v”等价于“把 -3 个物品从 v 送到 u”</p>

<p>在最大流问题中，c 和 f 满足三个性质：</p>

- 容量限制：f(u, v) <= c(u, v)

- 斜对称性：f(u, v) = -f(v, u)

- 流量平衡：对于除了 s 和 t 以外的所有任意结点 u，`\sum_{(u, v) in E}f(u, v) = 0`

<p>目标是最大化 |f|</p> 

$$
|f| = \sum_{(s, v) \in E}f(s, v) = \sum_{(u, t) \in E}f(u, t)
$$

</br>

# 增广路算法

</br>

<p>计算每条边上容量与流量之差为残量，得到残量网络</p>

<p>该算法基于这样一个事实：残量网络中任何一条从 s 到 t 的有向道路都对应一条原图中的增广路(augmenting path)，只要求出该道路中所有残量的最小值 d，把对应的所有边上的流量增加 d 即可，该过程称为增广。</p>

<p>显然只要残量网络中存在增广路，流量就可以增大。逆命题也成立：如果残量网络中不存在增广路，则当前流就是最大流</p>

<p>找任意路径最简单的办法无疑是用 DFS，但很容易找到让算法很慢的例子，稍好的方法是使用 BFS，这就是 Edmonds-Karp 算法</p>

<p>虽然有了 flow 和 cap，但得益于Edge结构体的设计，Edmonds-Karp 和 Dijkstra 等算法很相近</p>

```
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e7;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int cap, flow;
};

int h[N];
int ne[N];
int e[N];
Edge w[N];
int idx;

int a[N]; // a 记录改进量
int p[N]; // p 记录入点

void add(int a, int b, Edge c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}

int EdmondsKarp(int s, int t)
{
    int flow = 0;
    while(true)
    {
        memset(a, 0, sizeof a);
        queue<int> q;
        q.push(s);
        a[s] = INF;
        while(!q.empty())
        {
            int x = q.front();
            q.pop();
            for(int i = h[x]; i != -1; i = ne[i])
            {
                int y = e[i];
                int c = w[i].cap, f = w[i].flow;
                if(!a[y] && c > f) // 这里 !a[y] 很细节
                {
                    p[y] = x;
                    a[y] = min(a[x], c - f);
                    q.push(y);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        
        for(int u = t; u != s; u = p[u])
        {
            for(int i = h[p[u]]; i != -1; i = ne[i])
                if(e[i] == u)
                {
                    w[i].flow += a[t];
                    w[i^1].flow -= a[t];
                }
        }
        flow += a[t];
    }
    return flow;
}

int main()
{
    memset(h, -1, sizeof h);
    
    int n, m;
    cin >> n >> m;
    
    for(int i = 0; i < m; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, {c, 0}), add(b, a, {0, 0});
    }
    
    int f = EdmondsKarp(1, n);
    cout << f;
}
```

<p>该版本能处理环，<b>但无法处理重边</b></p>

```
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;

vector<vector<int>>g;
vector<int> pre;
vector<int> a;
int n, m;

int EK(){
    int flow=0;
    queue<int> q;
    while(true){
        q.push(1);
        a.assign(n+1,0);
        a[1]=1000;//源点流量无穷大
        while(!q.empty()){
            int vex=q.front();
            q.pop();
            for(int i=1;i<n+1;i++){
                if(g[vex][i]>0 && a[i]==0){
                    a[i]=min(a[vex],g[vex][i]);
                    q.push(i);
                    pre[i]=vex;
                }
            }
        }
        if(a[n]==0){
            return flow;
        }
        flow+=a[n];
        for(int i=n;i!=1;i=pre[i]){//更新剩余网络
            g[pre[i]][i]-=a[n];
            g[i][pre[i]]+=a[n];
        }
    }

}

int main()
{
    cin>>n>>m;
    g.assign(n+1,vector<int>(n+1));
    pre.assign(n+1,0);
    int u, v, c;
    for(int i=0;i<m;i++){
        cin>>u>>v>>c;
        g[u][v]+=c;
    }
    cout<<EK();
    return 0;
}
```

<p>该版本能处理重边</p>

```
struct Edge
{
    int from, to, cap, flow;
    
    Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f) {}
};

struct EdmondsKarp
{
    int n, m;
    
    vector<Edge> edges;
    vector<int> G[maxn];
    int a[maxn];
    int p[maxn];
    
    void init(int n)
    {
        for(int i = 0; i < n; i ++) G[i].clear();
        edges.clear();
    }
    
    void AddEdge(int from, int to, int cap)
    {
        edges.push_back(Edge(from, to, cap, 0));
        edges.push_back(Edge(to, from, 0, 0));
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1)
    }
    
    int Maxflow(int s, int t)
    {
        int flow = 0;
        for(;;)
        {
            memset(a, 0, sizeof a);
            queue<int> q;
            q.push(s);
            a[s] = INF;
            while(!q.empty())
            {
                int x = q.front();
                q.pop();
                for(int i = 0; i < G[x].size(); i ++)
                {
                    Edge &e = edges[G[x][i]];
                    if(!a[e.to] && e.cap > e.flow)  // 该点未访问且残余容量 > 0
                    {
                        p[e.to] = G[x][i];
                        a[e.to] = min(a[x], e.cap - e.flow)
                        q.push(e.to);
                    }
                }
                if(a[t]) break;
                
            }
            if(!a[t]) break;
            for(int u = t; u != s; u = edges[p[u]].from)
            {
                edges[p[u]].flow += a[t];
                edges[p[u] ^ 1].flow -= a[t];
            }
            flow += a[t];
        }
        return flow;
    }
};
```

<P>pro max 版本</P>

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































