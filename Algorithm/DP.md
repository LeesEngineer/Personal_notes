</br>

# 动态规划的理解

</br>

<p>动态规划是一种优化算法，用于解决具有重叠子问题和最优子结构性质的问题。动态规划通过将复杂问题分解为更简单的子问题，并存储这些子问题的解来避免重复计算，从而提高效率。</p>

<p>个人理解动态规划：要从两个角度来考虑，第一个是状态表示，第二个是状态计算。所谓状态就是一个未知数。</p>

<p>比较难的DP问题，还会涉及对DP的优化，是对动态规划的代码或动态规划的方程做一个等价变形，所以一定要把基本的形式写出来，再做优化，比如说背包问题，最好的方法是用一维数组去写，但考虑的时候一定要从最朴素的方向去考虑，这样才能知道思维的一个过程</p>

<p>是从集合的角度去理解问题，<b>DP问题的每一个状态表示的是一个集合</b>，需要考虑清楚的是f(i,j)表示的是哪一个集合</p>

*   状态表示：就是思考我们要用几维的状态来表示，状态考虑也可以从两个角度去考虑。一般来说背包问题是二维的，f(i,j)。
*   *   他表示的集合是什么，是所有选法的一个集合，条件是:1.只从前i个物品中去选，2.选出来的物品的总体积小于等于j
*   *   f(i,j)表示的集合的属性是什么，属性常见的有最大值，最小值，元素的数量，背包问题的属性是最大值
*   状态计算：如何能一步一步的把我们的每一个状态计算出来

<p>f(i,j)表示的是集合的某种属性，集合里面是所有选法，但属性的话是一个值，最终会落实到这个值上面</p>

<p>所有DP：状态表示是什么，状态计算是什么，状态表示是哪一个集合的那种属性，集合里面的元素要满足哪些条件呢，状态计算就是集合的划分可以把当前的集合划分为哪些类呢，分完之后可以使每一类都算出来</p>

<p></p>

<p></p>

<p></p>

</br>

# 背包问题

</br>

<p>给我们N个物品和一个容量是V的背包，每一个物品有两个属性，体积Vi，价格（权重）Wi，问题是：挑选一些物品，在装得下的情况下，选出来的物品的最大的总价值是多少</p>

## 01背包问题

<p>每件物品最多只能用一次</p>

<p>01背包问题里面集合的划分是一个很经典的划分，会把f(i,j)的这个集合划分成两个子集，其实是把他表示的选法分为两大类，第一类是不包含第i个物品，第二类是包含第i个物品,满足不重不漏</p>

1.  第一类就是从 1～i-1 中选，不超过j的集合，可以用f(i-1,j)来表示，所以第一类的最大值就是f(i-1,j)，第一类情况一定存在
2.  1.  第二类（算第二种情况的最大值就是背包问题的难点），从 1～i 中选，不超过j的集合，还要包含i的集合。直接求不好求，需要曲线救国。先把每种选法里面的第i个物品全部去掉，**不影响我们的最大值是谁，问题就转变为从 1～i-1 中选，不超过j-vi，这样的一个集合其实就是f(i-1,j-vi)，也就表示这些选法的一个最大值，**f(i-1,j-vi)+wi**就是我们要求的一个最大值。** 当vi大于j时，第二类情况不存在。

`f(i, j) = Max(f(i - 1, j), f(i - 1, j - vi) + wi)`

<p>这就是背包问题的状态计算的方式</p>

### 二维表示01背包问题

    #include <iostream>
    #include <algorithm>

    using namespace std;

    const int N = 1010;

    int n, m;
    int v[N], w[N];
    int f[N][N];

    int main()
    {
        cin >> n >> m;
        
        for (int i = 1; i <= n; i++ ) cin >> v[i] >> w[i];
        
        for (int i = 1; i <= n; i++ )
            for (int j = 0; j <= m; j++ )
            {
                f[i][j] = f[i - 1][j];
                if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            }
            
        cout << f[n][m] << endl;
        
        return 0;
    }
